
/*
 *=============================================================================
 * Copyright (C) 2008 Alon Zakai ('Kripken') kripkensteiner@gmail.com
 *
 * This file is part of the Intensity Engine project,
 *    http://www.intensityengine.com
 *
 * The Intensity Engine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * The Intensity Engine is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with the Intensity Engine.  If not, see
 *     http://www.gnu.org/licenses/
 *     http://www.gnu.org/licenses/agpl-3.0.html
 *=============================================================================
 */


#include <map>

#include "tools.h"

//! All out new messages types should have higher value. This might be lower than the current '1000', and it might
//! then fit into a char, for better network bandwidth...
#define INTENSITY_MSG_TYPE_MIN 1000

//! As per Sauer: 0 is fast positions, 1 is (reliable?) standard messages
#define MAIN_CHANNEL 1


//! Extensions to the Sauerbraten client-server messaging system

//! Instead of hard-coding messages into fpsserver.h as in Sauerbraten, we instead have the
//! following general system, where MessageTypes are registered, and the MessageManager then
//! calls the appropriate MessageType to handle a packet. Message types themselves are defined
//! in the messages.template file, which is then used to autogenerate C++ code, with no risk
//! of misreading or miswriting.

namespace MessageSystem
{

//! The goal with MessageType is to encapsulate in one local area all the logic related to one message. In particular,
//! we should strive to have both the code generating the message and the code reading the message here (and not spread
//! out over client and server files separately as in Sauer). Another goal is to not conflate server and client messages:
//! There should be a different message type for server->client and client->server, even if they are very similar
//! (if so, inheritance of other code-sharing methods are relevant), unlike Sauer which reuses the messages for both
//! directions, and it seems that this means not all message contents are used (one direction might not need it all) -
//! but not sure about that.

struct MessageType
{
    int         type_code; //!< Each message type has a unique code, as in Sauer.
    std::string type_name; //!< Message names are useful for debugging, but not sent over the wire

    MessageType(int code, std::string name) : type_code(code), type_name(name) { assert(type_code >= INTENSITY_MSG_TYPE_MIN); };
    virtual ~MessageType() { };

    //! Receive a message
    virtual void receive(int receiver, int sender, ucharbuf &p);
};


//! Management of messages - the list of all (non-Sauer) message types, and a way to call them as needed

struct MessageManager
{
    typedef std::map<int, MessageType*> MessageMap;

    //! The message types in our system
    static MessageMap messageTypes;

    // TODO: a quit() that deletes all the new()ed messagetypes

    //! Register an individual message type
    static void registerMessageType(MessageType *newMessageType);
    //! Register all messages - a hardcoded list of our messages, in effect. Autogenerated.
    static void registerAll();

    //! Handle a packet from the server, with the appropriate messagetype handler. Returns false if the type is unknown
    //! receiver - clientnumber of the receiver. On clients there is only the player, but on the server there might be
    //! many NPCs.
    static bool receive(int type, int receiver, int sender, ucharbuf &p);

    //! Simple storage of the current file we expect in a file transfer. We have this because sauer file transfers lack
    //! a filename
    static void awaitFile(std::string name);

    //! Get the name of the file we are awaiting; it is the name we should save as
    static std::string getAwaitingFile();
};

// Include all the procedurally-generated message data
#include "messages.h"

};

